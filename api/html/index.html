<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>EDGE Data Model: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EDGE Data Model
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">EDGE Data Model Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>#EDGE Process Automation Interface</p>
<h2>Overview</h2>
<p>The purpose of this document is to provide an ICD (Interface Control Document) for the Ensign EDGE Automation Interface. The purpose is to communicate all possible inputs to and all potential outputs from the EDGE system for some potential or actual user of the system. This document describe the following</p>
<ul>
<li>The inputs and outputs of the EDGE Process Automation Interface.</li>
<li>The interface between two systems or subsystems, e.g. "The Edge control system and, but not limited to, the Shell Auto Tuner"</li>
<li>The complete interface protocol from the lowest physical elements (e.g., Profinet) to the highest logical levels (e.g., EDGE Process Automation Interface).</li>
</ul>
<p>This ICD will only describe the interface itself, and not the characteristics of the systems which use it to connect. The function and logic of those systems will be described in their own design documents if required. In this way, independent teams can develop the connecting systems which use the interface specified, without regard to how other systems will react to data and signals which are sent over the interface. This ICD will include information about the type, description, and unit of what is measured by the data, but not any ultimate meaning of the data in its intended use by any user.</p>
<h2>Communication</h2>
<p>All communication between the EDGE control system and the Shell Auto Tuner will be expressed as normalized topics which use the DDS (Data Distribution Service) publish/subscribe protocol to provide asynchronous communication. Certain QoS (quality of service) attributes will be available for to the Shell Auto Tuner to determine the quality of the data it is receiving as well as the state of the data it has requested. These QoS attributes will allow the Shell Auto Tuner to specify specific events (or timers) for notification of data arrival, deadlines, etc. A communication pattern known as Objective/State (similar to observer pattern) will be used to distribute objectives to the Rig Control System.</p>
<p>For safety reasons all process level requests to the system are merely suggestions and the EDGE control system will decide if the request is within the specified safety margins.</p>
<div class="image">
<img src="./Interface/Interface.001.jpeg"  alt="Interface"/>
</div>
<h3>Objective/State</h3>
<p>The objective/state pattern utilizes two actors. One actor represents a requestor and the other represents an effector. There can be a many-to-many relationship between requestors and effectors. This allows the communication between the Rig Control System (the control layer) and the Edge Process Automation Interface (the process layer) to be data-centric. It also allows the process layer to remain agnostic about the underlying control system. Focusing on the functional aspects of the system rather then detailed knowledge of how the Rig Control system functions. Allows components to express intent and communicate about actions</p>
<ul>
<li>Allows additional observing components to leverage request, objective data</li>
<li>Avoids tight application-to-application coupling of RPC-like (anti-)patterns</li>
</ul>
<h4>Objective State Pattern: Use Cases</h4>
<ul>
<li>How can one party request that another party do something?</li>
<li>How can a producer know that observers(s) have acted on its data?</li>
<li>How can a producer observe the “result” of a remote action?</li>
</ul>
<h4>Requestor</h4>
<p>A requestor is an actor which "requests" the resources of another actor. A requestor makes a "request" by stating its intentions or publishing the intended state to the system. The request is completely asynchronous which means that the requestor must observe the current state of the system to see if the request is being handled by the system. Requestors perform the following responsibilities:</p>
<ul>
<li>publish requests to the system</li>
<li>observe current state of the system</li>
</ul>
<h4>Effector</h4>
<p>The effector is an actor which can satisfy the state of a requestor. Effectors perform the following responsibilities:</p>
<ul>
<li>observe intended state changes</li>
<li>publish the current state of the effector</li>
</ul>
<h4>QoS</h4>
<p>The following QoS policies will be supported in the first release of the interface. These QoS policies are configurable at runtime. The policies should not be baked into the code but set by the consumer of the data.</p>
<h5>Reliability Policies</h5>
<p>Reliability controls the guarantee of packet delivery as well as historical persistence.</p>
<p>For some use cases, such as the periodic update of sensor values to a GUI displaying the value to a person, "best effort" delivery is often good enough. It is certainly the fastest, most efficient, and least resource-intensive (CPU and network bandwidth) method of getting the newest/latest value for a topic from DataWriters to DataReaders. But there is no guarantee that the data sent will be received. It may be lost due to a variety of factors, including data loss by the physical transport such as wireless RF or even Ethernet. Packets received out of order are dropped and a SAMPLE_LOST Status is generated.</p>
<p>However, there are data streams (topics) in which you want an absolute guarantee that all data sent by a DataWriter is received reliably by DataReaders. This means that Connext DDS must check whether or not data was received, and repair any data that was lost by resending a copy of the data as many times as it takes for the DataReader to receive the data.</p>
<ul>
<li><em>Reliability</em> - Specifies whether or not DDS will deliver data reliably.</li>
<li><em>History</em> - Specifies how much data must be stored by the middleware.</li>
</ul>
<h5>Durability Policies</h5>
<p>Because the publish-subscribe paradigm is connectionless, applications can create publications and subscriptions in any way they choose. As soon as a matching pair of DataWriters and DataReaders exist, then data published by the DataWriter will be delivered to the DataReader. However, a DataWriter may publish data before a DataReader has been created. For example, before you subscribe to a magazine, there have been past issues that were published.</p>
<p>This QosPolicy can be used to help ensure that DataReaders get all data that was sent by DataWriters, regardless of when it was sent. This QosPolicy can increase system tolerance to failure conditions. The following options are available for durability:</p>
<ul>
<li><em>Volatile Durability</em> - Do not save or deliver old data samples.</li>
<li><em>Transient Local</em> - Save and deliver old data samples if the publishing application still exists.</li>
<li><em>Transient Durability</em> - Save and deliver old data samples using a memory-based service.</li>
<li><em>Persistence Durability</em> - Save and deliver old data samples using disk-based service.</li>
</ul>
<h5>QoS Events</h5>
<ul>
<li><em>OnDataAvailable</em> - Mechanism to notify a subscriber when new data is available for reading.</li>
<li><em>OnLivelinessLost</em> - Mechanism to notify a subscriber that a producer of data is no longer valid. Does not tell us why the DataWrtier is no longer available.</li>
<li><em>OnDeadlineMissed</em> - Mechanism to notify a subscriber that the expected deadline for a new data sample has expired.</li>
<li><em>OnDataDisposed</em> - Mechanism to notify a subscriber that the DataWriter has disposed of the topic instance. This instnace will never be seen again</li>
<li><em>OnPublicationMatched</em> - Mechanism to notify a subscriber that a new publisher is available.</li>
</ul>
<h5>OnDataAvailable</h5>
<p>The <em>OnDataAvailable</em> QoS policy requests a specific mechanism to be notified when new samples of data arrive. The subscribing application may want to act immediately on new data samples. This mechanism allows the subscribing application to base arrival of data on events rather than traditional polling mechanisms. The SAMPLE_INFO structure will inform the subscribing application about the validity of the data sample.</p>
<h5>OnLivelinessLost</h5>
<p>The <em>OnLivelinessLost</em> QoS policy requests a specific mechanism for the publishing application to maintain the liveliness of all subscribing entities. The subscribing application may want to know that the publishing application is explicitly asserting the liveliness of the matching DataWriter rather than inferring its liveliness. The subscribers lease_duration specifies the maximum period at which matching Publishers must have their liveliness asserted. In addition, in the subscribing application DDS uses an internal thread that wakes up at the period set by the subscribers lease_duration to see if the publishers lease_duration has been violated.</p>
<h5>OnDeadlineMissed</h5>
<p>This <em>OnDeadlineMissed</em> QoS policy states the maximum period in which the application expects to receive new values for the Topic. The application may receive data faster than the rate set by this QoS policy. You can use this QoS policy during system integration to ensure that applications have been coded to meet design specifications. You can also use it during run time to detect when systems are performing outside of design specifications. Receiving applications can take appropriate actions to prevent total system failure when data is not received in time. For topics on which data is not expected to be periodic, the deadline period should be set to an infinite value.</p>
<h5>OnPublicationMatched</h5>
<p>This <em>OnPublicationMatched</em> QoS policy informs the subscriber that a publisher is now available in the system. This QoS policy can be used to inform the application the state of the system. If there is a publisher available</p>
<h2>Safe Operation</h2>
<p>To ensure safe operation of the control system the platform solution must ensure that there is only every a single owner of the process and/or tool. The platform must also ensure that any set-points presented to the system which fall outside the normal operating range will be disregarded by the system.</p>
<h3>Single tool owner</h3>
<p>To ensure safe operations of the system there can only ever be a single owner of the rig control system. The driller MUST be presented a mechanism to easily switch between application and manual input.</p>
<h3>Validation of set-points</h3>
<p>Validation of set-points will take place at multiple levels. First it is the responsibility of the optimization application to only send values within the constraints specified in the <em>State</em> interface. Second the networker will be responsible for validating any input it receives from the application. If a value is determined to be outside the safe operating limits then the networker will disregard the suggested set-points and not send them to the control system. Finally it will be the responsibility of the control system to vet all set points it receives to ensure the values are within safe tool limits.</p>
<h2>Interfaces</h2>
<p>This section details the interfaces that are available in the EDGE Process Automation interface. Interfaces are broken into two categories <em>Request</em> and <em>State</em>. <em>Requests</em> are used to infer state to the environment while <em>State</em> interfaces are used to observe a stateful view of the environment.</p>
<p><em>Request</em> and <em>State</em> always have the following framework data members <em>id</em> and <em>timestamp</em> The <em>id</em> is the unique id of the requester. The <em>id</em> is the primary key of the topic and is used to differentiate this topic from other topics of the same type. The <em>timestamp</em> is the time the data sample was published. At the time of delivery the framework will take the timestamp from the sample metadata that was produced by the publisher and store it in the sample. This is done to allow the consumer of the data the opportunity to make queries on the samples based on a specified time series.</p>
<h3>Type</h3>
<h3>Units</h3>
<p>All units are specified in derived SI. It is the responsibility of all producers and consumers to do proper unit conversions to/from SI before publishing or consuming the data. Specifying a standard base unit system allows the consumer of the data to easily and dynamically determine a unit without affecting the interface.</p>
<h3>Interface Structure</h3>
<p>All interfaces follow a very specific structure. All interfaces have an ID which is the primary key and a timestamp which represents the time the data was published by the source. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 14 2018 07:37:00 for EDGE Data Model by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
